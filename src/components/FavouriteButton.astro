---
// ========================================
// FAVOURITE BUTTON COMPONENT
// Flexible favourite button with multiple presentation modes
// Supports: icon-only, text-only, or icon+text variants
// ========================================

interface Props {
  propertyId: string
  size?: 'sm' | 'md' | 'lg'
  source?: string
  /** @deprecated Use variant="icon-text" instead */
  showLabel?: boolean
  /**
   * Presentation variant:
   * - 'icon': Heart icon only (default)
   * - 'text': Text label only ("Add to Favourite" / "Remove from Favourite")
   * - 'icon-text': Heart icon with text label
   */
  variant?: 'icon' | 'text' | 'icon-text'
  /** Custom label text (defaults: "Save" / "Saved") */
  labelText?: string
  /** Custom label text for favourited state */
  labelTextActive?: string
}

const {
  propertyId,
  size = 'md',
  source = 'unknown',
  showLabel = false,
  variant: variantProp,
  labelText = 'Save',
  labelTextActive = 'Saved'
} = Astro.props

// Determine variant - showLabel provides backward compatibility
const variant = variantProp || (showLabel ? 'icon-text' : 'icon')

// Build class list
const sizeClass = size !== 'md' ? `favourite-btn--${size}` : ''
const variantClass = `favourite-btn--${variant}`

// Show icons for 'icon' and 'icon-text' variants
const showIcon = variant === 'icon' || variant === 'icon-text'
// Show label for 'text' and 'icon-text' variants
const showLabelText = variant === 'text' || variant === 'icon-text'
---

<button
  type="button"
  class:list={['favourite-btn', sizeClass, variantClass]}
  data-property-id={propertyId}
  data-source={source}
  data-label-text={labelText}
  data-label-text-active={labelTextActive}
  aria-label="Add to favourites"
  title="Add to favourites"
>
  {showIcon && (
    <>
      <!-- Heart Outline (default state) -->
      <svg
        class="favourite-btn__icon favourite-btn__icon--outline"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
      </svg>

      <!-- Heart Filled (favourited state) -->
      <svg
        class="favourite-btn__icon favourite-btn__icon--filled"
        viewBox="0 0 24 24"
        fill="currentColor"
      >
        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
      </svg>

      <!-- Loading Spinner -->
      <svg
        class="favourite-btn__spinner"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2.5"
      >
        <circle cx="12" cy="12" r="10" stroke-opacity="0.25"/>
        <path d="M12 2a10 10 0 0 1 10 10" stroke-linecap="round"/>
      </svg>
    </>
  )}

  {/* Text-only loading spinner */}
  {variant === 'text' && (
    <svg
      class="favourite-btn__spinner favourite-btn__spinner--inline"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2.5"
    >
      <circle cx="12" cy="12" r="10" stroke-opacity="0.25"/>
      <path d="M12 2a10 10 0 0 1 10 10" stroke-linecap="round"/>
    </svg>
  )}

  {showLabelText && (
    <span class="favourite-btn__label">{labelText}</span>
  )}
</button>

<style lang="scss">
  @use '../styles/components/favourite-button';
</style>

<script>
  // ========================================
  // FAVOURITE BUTTON INTERACTIONS
  // ========================================

  /**
   * Wait for StratosTracker to be available
   * Returns the tracker or null after max retries
   */
  async function waitForTracker(maxRetries: number = 10, retryDelay: number = 100): Promise<any> {
    for (let i = 0; i < maxRetries; i++) {
      if (window.StratosTracker) {
        return window.StratosTracker
      }
      await new Promise((resolve) => setTimeout(resolve, retryDelay))
    }
    return null
  }

  const initFavouriteButtons = async () => {
    const tracker = await waitForTracker()

    if (!tracker) {
      console.warn('[FavouriteButton] Tracker not available after retries')
      return
    }

    document.querySelectorAll('.favourite-btn').forEach((btn) => {
      const propertyId = (btn as HTMLElement).dataset.propertyId
      const source = (btn as HTMLElement).dataset.source || 'unknown'

      if (!propertyId) return

      // Check initial state
      checkFavouriteState(btn as HTMLElement, propertyId, tracker)

      // Handle click
      btn.addEventListener('click', async (e) => {
        e.preventDefault()
        e.stopPropagation()

        if (btn.classList.contains('is-loading')) return

        // Show loading state
        btn.classList.add('is-loading')

        try {
          // toggleFavourite now returns { is_favourited, count }
          const result = await tracker.toggleFavourite(propertyId, source)

          // Update button state
          updateButtonState(btn as HTMLElement, result.is_favourited)

          // Trigger pulse animation
          triggerPulseAnimation(btn as HTMLElement)

          // Update navbar count using returned count (no extra API call!)
          updateNavbarCount(result.count)

          // Show toast
          showToast(
            result.is_favourited ? 'Added to favourites' : 'Removed from favourites',
            result.is_favourited
          )

        } catch (error) {
          console.error('[FavouriteButton] Error:', error)
          showToast('Failed to update', false)
        } finally {
          btn.classList.remove('is-loading')
        }
      })
    })

    console.log(`[FavouriteButton] Initialized`)
  }

  async function checkFavouriteState(btn: HTMLElement, propertyId: string, tracker: any) {
    try {
      const isFavourited = await tracker.isFavourited(propertyId)
      updateButtonState(btn, isFavourited)
    } catch (error) {
      console.error('[FavouriteButton] State check error:', error)
    }
  }

  function updateButtonState(btn: HTMLElement, isFavourited: boolean) {
    const label = btn.querySelector('.favourite-btn__label')
    const labelText = btn.dataset.labelText || 'Save'
    const labelTextActive = btn.dataset.labelTextActive || 'Saved'

    if (isFavourited) {
      btn.classList.add('is-favourited')
      btn.setAttribute('aria-label', 'Remove from favourites')
      btn.setAttribute('title', 'Remove from favourites')
      if (label) label.textContent = labelTextActive
    } else {
      btn.classList.remove('is-favourited')
      btn.setAttribute('aria-label', 'Add to favourites')
      btn.setAttribute('title', 'Add to favourites')
      if (label) label.textContent = labelText
    }
  }

  function triggerPulseAnimation(btn: HTMLElement) {
    btn.classList.add('is-animating')
    setTimeout(() => btn.classList.remove('is-animating'), 600)
  }

  function updateNavbarCount(count: number) {
    document.querySelectorAll('.favourites-count').forEach((el) => {
      (el as HTMLElement).textContent = count.toString();
      (el as HTMLElement).style.display = count > 0 ? 'flex' : 'none'
    })
  }

  function showToast(message: string, isSuccess: boolean) {
    // Remove existing toasts
    document.querySelectorAll('.favourite-toast').forEach(t => t.remove())

    const toast = document.createElement('div')
    toast.className = 'favourite-toast'
    toast.innerHTML = `
      <span class="favourite-toast__icon">${isSuccess ? '‚ù§Ô∏è' : 'üíî'}</span>
      <span>${message}</span>
    `

    document.body.appendChild(toast)

    // Auto-hide after 2.5s
    setTimeout(() => {
      toast.classList.add('is-hiding')
      setTimeout(() => toast.remove(), 300)
    }, 2500)
  }

  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initFavouriteButtons)
  } else {
    initFavouriteButtons()
  }
</script>
