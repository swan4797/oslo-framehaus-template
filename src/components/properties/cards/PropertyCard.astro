---
// ========================================
// PROPERTY CARD COMPONENT
// Clean, modern property listing card
// Includes click tracking, favourite button & image slider
// ========================================

import type { Property } from '../../../types/database'
import FavouriteButton from '../../FavouriteButton.astro'
import {
  getPropertyUrl,
  getDisplayPrice,
  getThumbnailUrl,
  formatPropertyType,
} from '../../../lib/utils'

interface Props {
  property: Property
  featured?: boolean
  source?: string
}

const { property, featured = false, source = 'search_results' } = Astro.props

// Computed values
const propertyUrl = getPropertyUrl(property)
const displayPrice = getDisplayPrice(property)
const thumbnailUrl = getThumbnailUrl(property)
const propertyType = formatPropertyType(property.property_type)
const propertyStyle = property.property_style || null

// Get floor area with fallback to internal_area
const floorArea = property.floor_area || property.internal_area || null

// Truncate text helper - clean truncation without breaking words
const truncateText = (text: string, maxLength: number): string => {
  if (!text || text.length <= maxLength) return text

  // Find the last space within the limit to avoid breaking words
  const truncated = text.substring(0, maxLength)
  const lastSpace = truncated.lastIndexOf(' ')

  // If there's a space, truncate at the word boundary; otherwise use the full limit
  const cleanTruncated = lastSpace > maxLength * 0.7 ? truncated.substring(0, lastSpace) : truncated

  return `${cleanTruncated.trim()}...`
}

// Build description from property data (same logic as PropertyListCard)
const buildDescription = (): string => {
  // Priority: description > summary > key_features > fallback
  let rawDescription = ''

  if (property.description && property.description.trim()) {
    rawDescription = property.description
  } else if (property.summary && property.summary.trim()) {
    rawDescription = property.summary
  } else if (property.key_features && property.key_features.length > 0) {
    // Use key features as description if no description/summary
    rawDescription = property.key_features.slice(0, 3).join('. ') + '.'
  }

  if (rawDescription) {
    // Strip HTML tags if present and truncate
    const cleanText = rawDescription.replace(/<[^>]*>/g, '').trim()
    return truncateText(cleanText, 120)
  }

  // Fallback: build a basic description from property details
  const parts: string[] = []

  if (property.bedrooms) {
    parts.push(`${property.bedrooms} bedroom`)
  }

  if (propertyType) {
    parts.push(propertyType.toLowerCase())
  }

  if (property.city) {
    parts.push(`in ${property.city}`)
  } else if (property.display_address) {
    parts.push(`in ${property.display_address}`)
  }

  return parts.length > 0 ? `A ${parts.join(' ')}.` : ''
}

const description = buildDescription()

// Get images for slider gallery (same logic as PropertyListCard)
const getGalleryInfo = (): { images: Array<{ url: string; alt: string }>; totalCount: number } => {
  // If property_media exists and has images, use those
  if (property.property_media && property.property_media.length > 0) {
    const allImages = property.property_media
      // Filter for images only (if media_type exists), or include all if no media_type
      .filter(media => !media.media_type || media.media_type === 'image')
      .sort((a, b) => {
        // Primary images first
        if (a.is_primary && !b.is_primary) return -1
        if (!a.is_primary && b.is_primary) return 1
        // Then by display_order
        return (a.display_order || 0) - (b.display_order || 0)
      })

    const totalCount = allImages.length
    const images = allImages
      .slice(0, 5)
      .map((media, index) => ({
        url: media.thumbnail_url || media.file_url,
        alt: media.alt_text || `${property.display_address} - Image ${index + 1}`
      }))

    if (images.length > 0) return { images, totalCount }
  }

  // Fallback: always show the main thumbnail (thumbnailUrl is always defined)
  return {
    images: [{ url: thumbnailUrl, alt: property.display_address || 'Property image' }],
    totalCount: 1
  }
}

const { images: galleryImages, totalCount: totalImageCount } = getGalleryInfo()
const hasMultipleImages = galleryImages.length > 1
// Show "more photos" placeholder if there are more than 5 images
const hasMorePhotos = totalImageCount > 5
const remainingPhotosCount = totalImageCount - 5
---

<article
  class:list={['property-card', { 'featured': featured }]}
  data-property-id={property.id}
  data-source={source}
  data-slider-card
>
  <a href={propertyUrl} class="property-card__link" data-property-url={propertyUrl}>

    <!-- Full-bleed Image Section with Overlay Content -->
    <div class="property-card__image-container" data-slider-container>
      <!-- Image Wrapper - contains all images stacked -->
      <div class="property-card__image-wrapper">
        {galleryImages.map((image, index) => (
          <img
            src={image.url}
            alt={image.alt}
            class:list={[
              'property-card__image',
              { 'property-card__image--active': index === 0 }
            ]}
            data-slide-index={index}
            loading={index === 0 ? 'eager' : 'lazy'}
          />
        ))}
        {/* "View More" Slide Placeholder */}
        {hasMorePhotos && (
          <div
            class="property-card__image property-card__more-slide"
            data-slide-index={galleryImages.length}
            data-more-slide
          >
            <div class="property-card__more-slide-content">
              <div class="property-card__more-slide-icon">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                  <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                  <circle cx="8.5" cy="8.5" r="1.5"/>
                  <polyline points="21 15 16 10 5 21"/>
                </svg>
              </div>
              <span class="property-card__more-slide-count">+{remainingPhotosCount}</span>
              <span class="property-card__more-slide-text">more photos</span>
              <span class="property-card__more-slide-cta">View full gallery</span>
            </div>
          </div>
        )}
      </div>

      <!-- Slider Navigation Arrows (only show if multiple images) -->
      {hasMultipleImages && (
        <div class="property-card__slider-nav" data-slider-nav>
          <button
            type="button"
            class="property-card__slider-arrow property-card__slider-arrow--prev"
            data-slider-prev
            aria-label="Previous image"
          >
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
          </button>
          <button
            type="button"
            class="property-card__slider-arrow property-card__slider-arrow--next"
            data-slider-next
            aria-label="Next image"
          >
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
          </button>
        </div>
      )}

      <!-- Favourite Button -->
      <div class="property-card__favourite" onclick="event.preventDefault(); event.stopPropagation();">
        <FavouriteButton
          propertyId={property.id}
          size="md"
          source={source}
        />
      </div>

      <!-- Status Badge (Newly Listed / Featured) -->
      {featured && (
        <div class="property-card__badge property-card__badge--status">
          Newly Listed
        </div>
      )}

      <!-- Content Overlay -->
      <div class="property-card__content">
        <!-- Header Row: Title + Price -->
        <div class="property-card__header">
          <!-- Address -->
          <h3 class="property-card__title">
            {truncateText(property.address_line_1 || '', 10)}
          </h3>
          <div class="property-card__price">
            <span class="property-card__price-value">{displayPrice}</span>
            {property.listing_type === 'let' && (
              <span class="property-card__price-suffix">/mo</span>
            )}
          </div>
        </div>

        <!-- Property Type & Style -->
        {(propertyType || propertyStyle) && (
          <p class="property-card__type">
            {propertyType}{propertyType && propertyStyle && ' • '}{propertyStyle}
          </p>
        )}

        <!-- Divider -->
        <div class="property-card__divider"></div>

        <!-- Specifications Row -->
        <div class="property-card__specs">
          <!-- Bedrooms -->
          <div class="property-card__spec">
            <svg class="property-card__spec-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M2 4v16"/>
              <path d="M2 8h18a2 2 0 0 1 2 2v10"/>
              <path d="M2 17h20"/>
              <path d="M6 8v9"/>
            </svg>
            <span class="property-card__spec-label">Bed:</span>
            <span class="property-card__spec-value">{property.bedrooms || 0}</span>
          </div>

          <span class="property-card__spec-divider"></span>

          <!-- Bathrooms -->
          <div class="property-card__spec">
            <svg class="property-card__spec-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 6 6.5 3.5a1.5 1.5 0 0 0-1-.5C4.683 3 4 3.683 4 4.5V17a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-5"/>
              <line x1="10" x2="8" y1="5" y2="7"/>
              <line x1="2" x2="22" y1="12" y2="12"/>
              <line x1="7" x2="7" y1="19" y2="21"/>
              <line x1="17" x2="17" y1="19" y2="21"/>
            </svg>
            <span class="property-card__spec-label">Baths:</span>
            <span class="property-card__spec-value">{property.bathrooms || 0}</span>
          </div>

          <span class="property-card__spec-divider"></span>

          <!-- Square Footage -->
          <div class="property-card__spec">
            <svg class="property-card__spec-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
              <rect x="3" y="3" width="18" height="18" rx="2"/>
            </svg>
            <span class="property-card__spec-label">Sqft:</span>
            <span class="property-card__spec-value">{floorArea || '—'}</span>
          </div>
        </div>
      </div>
    </div>
  </a>
</article>

<style lang="scss">
  @use '../../../styles/components/properties/cards/property-card';
</style>


<script>
  // ========================================
  // IMAGE SLIDER & CLICK TRACKING
  // Handles image slider navigation and property view tracking
  // ========================================

  document.addEventListener('DOMContentLoaded', () => {
    // ----------------------------------------
    // IMAGE SLIDER FUNCTIONALITY
    // ----------------------------------------

    const sliderCards = document.querySelectorAll('.property-card[data-slider-card]')

    sliderCards.forEach((card) => {
      const container = card.querySelector('[data-slider-container]')
      if (!container) return

      const images = container.querySelectorAll('.property-card__image')
      const prevBtn = container.querySelector('[data-slider-prev]')
      const nextBtn = container.querySelector('[data-slider-next]')

      if (images.length <= 1) return

      let currentIndex = 0
      const totalSlides = images.length
      const hasMoreSlide = container.querySelector('[data-more-slide]') !== null
      const lastImageIndex = totalSlides - 1

      // Update navigation button states
      const updateNavButtons = () => {
        if (prevBtn) {
          const isFirst = currentIndex === 0
          prevBtn.classList.toggle('property-card__slider-arrow--disabled', isFirst)
          ;(prevBtn as HTMLButtonElement).disabled = isFirst
        }
        if (nextBtn) {
          const isLast = currentIndex === lastImageIndex
          nextBtn.classList.toggle('property-card__slider-arrow--disabled', isLast)
          ;(nextBtn as HTMLButtonElement).disabled = isLast
        }
      }

      // Update active slide
      const goToSlide = (index: number) => {
        // Clamp to valid range (no wrap-around)
        if (index < 0) index = 0
        if (index > lastImageIndex) index = lastImageIndex

        currentIndex = index

        // Update images (including the more slide div)
        images.forEach((img, i) => {
          img.classList.toggle('property-card__image--active', i === currentIndex)
        })

        // Update nav button states
        updateNavButtons()
      }

      // Initialize nav button states
      updateNavButtons()

      // Previous button
      if (prevBtn) {
        prevBtn.addEventListener('click', (e) => {
          e.preventDefault()
          e.stopPropagation()
          goToSlide(currentIndex - 1)
        })
      }

      // Next button
      if (nextBtn) {
        nextBtn.addEventListener('click', (e) => {
          e.preventDefault()
          e.stopPropagation()
          goToSlide(currentIndex + 1)
        })
      }

      // Touch swipe support
      let touchStartX = 0
      let touchEndX = 0
      const minSwipeDistance = 50
      const htmlContainer = container as HTMLElement

      htmlContainer.addEventListener('touchstart', (e) => {
        touchStartX = e.changedTouches[0].screenX
      }, { passive: true })

      htmlContainer.addEventListener('touchend', (e) => {
        touchEndX = e.changedTouches[0].screenX
        const swipeDistance = touchEndX - touchStartX

        if (Math.abs(swipeDistance) > minSwipeDistance) {
          if (swipeDistance > 0 && currentIndex > 0) {
            // Swipe right - go to previous
            goToSlide(currentIndex - 1)
          } else if (swipeDistance < 0 && currentIndex < lastImageIndex) {
            // Swipe left - go to next
            goToSlide(currentIndex + 1)
          }
        }
      }, { passive: true })
    })

    // ----------------------------------------
    // CLICK TRACKING
    // ----------------------------------------

    const cardLinks = document.querySelectorAll('.property-card__link')

    // Key to mark property as tracked (shared with property page)
    const TRACKED_PROPERTY_KEY = '__stratos_tracked_property'

    cardLinks.forEach((link) => {
      link.addEventListener('click', () => {
        const card = link.closest('.property-card')
        if (!card) return

        const propertyId = (card as HTMLElement).dataset.propertyId
        const source = (card as HTMLElement).dataset.source || 'unknown'
        const propertyUrl = (link as HTMLElement).dataset.propertyUrl

        if (!propertyId) return

        if (window.StratosTracker) {
          try {
            // Mark this property as tracked so the page won't track again
            ;(window as any)[TRACKED_PROPERTY_KEY] = propertyId

            window.StratosTracker.trackPropertyView(propertyId, {
              source: source,
              clicked_from: window.location.pathname,
              referrer: document.referrer || 'direct',
              timestamp: new Date().toISOString()
            })

            console.log('[PropertyCard] Click tracked:', {
              property_id: propertyId,
              source: source,
              url: propertyUrl
            })
          } catch (error) {
            console.error('[PropertyCard] Tracking error:', error)
          }
        }
      })
    })

    console.log(`[PropertyCard] Initialized ${sliderCards.length} sliders, ${cardLinks.length} cards`)
  })
</script>
